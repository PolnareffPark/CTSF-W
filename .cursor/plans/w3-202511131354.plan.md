<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 57dae590-f6ea-4168-af78-653c63e23b19 -->
# W3 _W3PerturbWrapper 속성 접근 오류 근본 수정

## 문제 재분석

### 현재 발생한 에러

```python
File "/experiments/w3_experiment.py", line 365, in run
    model_tag = getattr(self.model.base, "model_tag", "HyperConv")
                        ^^^^^^^^^^^^^^^\
File "/experiments/w3_experiment.py", line 213, in __getattr__
    raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
AttributeError: '_W3PerturbWrapper' object has no attribute 'base'
```

### 근본 원인

#### 1. PyTorch nn.Module의 속성 저장 메커니즘

nn.Module은 특별한 `__setattr__`를 사용:

- `self.base = base` → `_modules['base']`에 저장
- 일반 속성처럼 `self.base` 접근 가능
- **하지만** `__getattr__`에서 명시적으로 차단하면 접근 불가

#### 2. __getattr__의 호출 시점

Python의 속성 접근 순서:

1. `__dict__` 확인
2. 클래스 속성 확인  
3. `__getattr__` 호출 (위에서 못 찾으면)

nn.Module의 경우:

1. `__dict__` 확인
2. `_modules` dict 확인 (nn.Module 특별 처리)
3. `__getattr__` 호출

**문제**: 우리의 `__getattr__`에서:

```python
if name in ('base', 'cfg', 'mode', ...):
    raise AttributeError(...)
```

→ `self.model.base` 접근 시 `__getattr__('base')`가 호출되고 즉시 에러

#### 3. W5 GateFixedModel과의 차이

**W5**:

- 일반 클래스 (nn.Module 상속 안 함)
- `self.model`이 일반 객체 속성
- `__getattr__`에서 `'model'` 체크로 무한 재귀 방지

**W3**:

- nn.Module 상속
- `self.base`가 `_modules`에 저장
- 일반적으로는 `__getattr__` 없이도 접근 가능
- 하지만 명시적 체크가 오히려 접근 차단

### 왜 이전에는 문제가 없었나?

이전 코드:

```python
model_tag = getattr(self.model, "model_tag", "HyperConv")
```

→ `self.model`에 `model_tag` 없음 → `__getattr__('model_tag')` 호출 → base로 위임 → 성공

수정 후 코드:

```python
model_tag = getattr(self.model.base, "model_tag", "HyperConv")
```

→ 먼저 `self.model.base` 접근 시도 → `__getattr__('base')` 호출 → 명시적 체크에 걸림 → 에러

## 해결 방안

### 옵션 A: __getattr__에서 명시적 체크 제거 (✓ 추천)

**장점**:

- 근본적 해결
- PyTorch nn.Module의 자연스러운 동작 활용
- 단순하고 명확

**구현**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근"""
    # __getattr__는 일반 속성 접근이 실패했을 때만 호출됨
    # self.base 등은 이미 _modules에 있어 정상 접근 가능
    # 여기 도달했다는 것은 wrapper 자체에 없는 속성이므로 base로 위임
    try:
        return getattr(self.base, name)
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

### 옵션 B: run()에서 self.model 사용

**현재**:

```python
model_tag = getattr(self.model.base, "model_tag", "HyperConv")
```

**수정**:

```python
model_tag = getattr(self.model, "model_tag", "HyperConv")
```

**장점**:

- wrapper를 투명 프록시로 사용 (올바른 패턴)
- `__getattr__`가 자동으로 base로 위임

**결론**: 옵션 A + 옵션 B 모두 적용

## 전체 수정 사항

### 1. _W3PerturbWrapper.**getattr** 수정

**위치**: experiments/w3_experiment.py line 206-219

**현재**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근 (W5 GateFixedModel 패턴)"""
    # nn.Module의 내부 속성과 wrapper 자체 속성은 부모 클래스가 처리
    # 이들은 이미 __init__에서 self.XXX로 설정되어 __dict__에 있으므로
    # __getattr__가 호출되지 않음. 하지만 명시적으로 체크하여 안전성 확보.
    if name in ('base', 'cfg', 'mode', 'roll_min', 'roll_max', 'smooth_kernel', 'seq_len'):
        # 이 경우는 발생하지 않아야 함 (이미 __dict__에 있음)
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
    
    # base 모델의 속성으로 위임
    try:
        return getattr(self.base, name)
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

**수정**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근"""
    # __getattr__는 일반 속성 접근이 실패했을 때만 호출됨
    # self.base, self.cfg 등은 이미 nn.Module의 _modules 또는 __dict__에 있어
    # 일반 접근으로 찾을 수 있으므로 __getattr__가 호출되지 않음
    # 여기 도달했다는 것은 wrapper 자체에 없는 속성이므로 base로 위임
    try:
        return getattr(self.base, name)
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

### 2. W3Experiment.run() 수정

**위치**: experiments/w3_experiment.py line 365

**현재**:

```python
model_tag = getattr(self.model.base, "model_tag", "HyperConv")
```

**수정**:

```python
model_tag = getattr(self.model, "model_tag", "HyperConv")
```

## 추가 검증 사항

### A. w3_metrics.py 검토

**파일 읽기 결과**: 파일이 원본과 동일

- `compute_w3_metrics` 함수만 존재
- 모델 속성 접근 없음
- 외부 데이터(baseline_metrics, perturb_metrics) 처리만
- **상태**: 문제 없음 ✓

### B. w3_plotting_metrics.py 검토

**파일 읽기 결과**: 파일이 원본과 동일

- `hooks_data`, `tod_vec` 등 외부 데이터 처리
- 모델 직접 접근 없음
- **상태**: 문제 없음 ✓

### C. 다른 wrapper 사용처 확인

**검색 필요**:

1. `self.model.base` 패턴이 다른 곳에도 있는지
2. wrapper의 다른 속성 접근이 있는지

## 테스트 계획

### 1. 속성 접근 테스트

```python
# _W3PerturbWrapper 객체에서:
wrapper.base           # _modules에서 찾음, __getattr__ 호출 안 됨
wrapper.cfg            # __dict__에서 찾음, __getattr__ 호출 안 됨
wrapper.xhconv_blks    # 없음 → __getattr__ 호출 → self.base.xhconv_blks 반환
wrapper.model_tag      # 없음 → __getattr__ 호출 → self.base.model_tag 반환
```

### 2. 실행 테스트

```bash
# 단일 실험
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode none

# 전체 모드
python run_suite.py --experiment W3 --datasets ETTm2 ETTh2 --horizons 96 --seeds 42 --resume all
```

### 3. 예상 결과

- ✓ AttributeError 없음
- ✓ 학습 완료
- ✓ 평가 완료  
- ✓ 모드별 차별화된 결과

## 이전 계획과의 차이점

### 이전 계획의 오류

**잘못된 가정**:

```python
if name in ('base', 'cfg', ...):
    raise AttributeError(...)
```

→ "이 경우는 발생하지 않아야 함"이라고 했지만, 실제로 발생함

**원인**:

- `self.model.base` 접근 시 `__getattr__('base')` 호출됨
- PyTorch nn.Module의 `_modules` 접근이 `__getattr__`보다 우선하지 않음

### 올바른 이해

PyTorch nn.Module의 속성 접근:

1. `__getattribute__` 먼저 호출 (항상)
2. `_modules`, `_parameters`, `_buffers` 확인
3. 못 찾으면 `__getattr__` 호출

하지만 `__getattr__`에서 명시적으로 에러를 발생시키면 접근 차단됨.

## 요약

| 항목 | 이전 계획 | 현재 상태 |

|------|-----------|-----------|

| **getattr** 명시적 체크 | 필요하다고 판단 | 불필요하고 오히려 문제 |

| model_tag 접근 | self.model.base | self.model (투명 프록시) |

| W5 패턴 참조 | 일반 클래스 패턴 | nn.Module 패턴으로 수정 필요 |

| w3_metrics.py | 미확인 | 문제 없음 확인 ✓ |

| w3_plotting_metrics.py | 미확인 | 문제 없음 확인 ✓ |

**결론**: 명시적 체크 제거 + run() 메서드 수정으로 완전 해결