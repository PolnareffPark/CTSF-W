<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 9aca50ab-cfde-46ba-b94d-b6065f9b9ade -->
# W3 실험 코드 검토 및 수정 플랜

## 검토 결과 요약

### 치명적 에러: 없음 ✓

이전 플랜에서 수정된 모든 치명적 문제들이 해결되었습니다:

- `_default_perturb_cfg`의 None 반환 문제 → 해결 (line 66-71에 기본값 추가)
- 세그먼트 퍼뮤테이션 로직 오류 → 해결 (line 234-255에서 슬라이싱 기반으로 재구현)
- 삼각 커널 생성 오류 → 해결 (line 294-298에서 float32 사용 및 정규화)

### 실험 지표 저장: 모두 정상 ✓

다음 모든 지표가 올바르게 저장됩니다:

1. `results_W3.csv` (line 536-540)
2. `forest_plot_detail.csv` (line 447-452)
3. `forest_plot_summary.csv` (line 546-551)
4. `gate_tod_heatmap_detail.csv & summary` (line 461-468)
5. `gate_distribution_detail.csv & summary` (line 470-474)
6. `window_errors_detail.csv` (line 500-523)
7. `perturb_delta_bar_detail.csv & summary` (line 554-559)

### 잠재적 문제: 5개 발견

---

## 발견된 잠재적 문제들

### 문제 1: _W3PerturbWrapper.__init__에서 비효율적인 초기화 로직

**위치**: `experiments/w3_experiment.py`, line 168-179

**현재 코드**:

```python
def __init__(self, base: nn.Module, mode: str, dataset: str, perturb_cfg: Optional[Dict[str, Any]] = None):
    super().__init__()
    self.add_module("base", base)
    self.mode = str(mode or "none")
    self.dataset = str(dataset or "")
    self.cfg = perturb_cfg.copy() if isinstance(perturb_cfg, dict) else _default_perturb_cfg(dataset)

    defaults = _default_perturb_cfg(dataset)
    for key, value in defaults.items():
        self.cfg.setdefault(key, value)

    self.tod_bins = _infer_tod_bins(self.dataset)
```

**문제점**:

- line 173: `perturb_cfg`가 None이면 `_default_perturb_cfg(dataset)` 호출
- line 175: 다시 `_default_perturb_cfg(dataset)` 호출 (중복)
- `perturb_cfg`가 None일 때 함수를 두 번 호출하므로 비효율적

**영향**:

- 정확성에는 영향 없음
- 성능에 미미한 영향 (함수 호출 오버헤드)

**수정 방안**:

```python
def __init__(self, base: nn.Module, mode: str, dataset: str, perturb_cfg: Optional[Dict[str, Any]] = None):
    super().__init__()
    self.add_module("base", base)
    self.mode = str(mode or "none")
    self.dataset = str(dataset or "")
    
    # 기본값 가져오기
    defaults = _default_perturb_cfg(dataset)
    
    # 사용자 제공 값이 있으면 복사 후 기본값으로 채우기, 없으면 기본값 사용
    if isinstance(perturb_cfg, dict):
        self.cfg = perturb_cfg.copy()
        for key, value in defaults.items():
            self.cfg.setdefault(key, value)
    else:
        self.cfg = defaults

    self.tod_bins = _infer_tod_bins(self.dataset)
```

---

### 문제 2: evaluate_test에서 예외 처리가 너무 광범위

**위치**: `experiments/w3_experiment.py`, line 393-405

**현재 코드**:

```python
try:
    exp_specific = compute_all_experiment_metrics(
        experiment_type=EXP_TAG,
        model=model_for_analysis,
        hooks_data=hooks if hooks else None,
        tod_vec=tod_vec,
        direct_evidence=direct,
        perturbation_type=self.cfg.get("mode", "none"),
    )
    if exp_specific:
        direct.update(exp_specific)
except Exception:
    pass
```

**문제점**:

- 모든 예외를 무시하고 로깅도 하지 않음
- 실제 에러 발생 시 디버깅이 어려움
- W3는 `compute_all_experiment_metrics`에서 빈 dict를 반환하므로 예외 발생 가능성은 낮지만, 다른 실험에서는 문제가 될 수 있음

**수정 방안**:

```python
try:
    exp_specific = compute_all_experiment_metrics(
        experiment_type=EXP_TAG,
        model=model_for_analysis,
        hooks_data=hooks if hooks else None,
        tod_vec=tod_vec,
        direct_evidence=direct,
        perturbation_type=self.cfg.get("mode", "none"),
    )
    if exp_specific:
        direct.update(exp_specific)
except Exception as e:
    import warnings
    warnings.warn(f"W3 compute_all_experiment_metrics failed: {e}")
```

---

### 문제 3: _detect_layout에서 L == C일 때 애매모호함

**위치**: `experiments/w3_experiment.py`, line 74-85

**현재 코드**:

```python
def _detect_layout(x: torch.Tensor) -> Tuple[int, int]:
    """
    입력 텐서의 시간축/채널축을 추정.
    허용 형태: (B, L, C) 혹은 (B, C, L)
    반환: (time_axis, channel_axis)
    """
    if x.dim() != 3:
        raise ValueError("W3 wrapper expects 3D input (B, L, C) or (B, C, L).")
    _, a1, a2 = x.shape
    if a1 >= a2:
        return 1, 2  # (B, L, C)
    return 2, 1  # (B, C, L)
```

**문제점**:

- `a1 == a2`일 때 (B, L, C)로 가정
- 예: (B, 96, 96)은 L=96, C=96일 수도 있고, L=96, C=96일 수도 있음
- 실제로는 시계열 데이터에서 L >> C가 일반적이므로 문제 될 가능성은 낮음

**수정 방안**:

```python
def _detect_layout(x: torch.Tensor) -> Tuple[int, int]:
    """
    입력 텐서의 시간축/채널축을 추정.
    허용 형태: (B, L, C) 혹은 (B, C, L)
    반환: (time_axis, channel_axis)
    
    일반적으로 시계열 길이(L)가 채널 수(C)보다 크다고 가정.
    L == C인 경우 (B, L, C)로 해석합니다.
    """
    if x.dim() != 3:
        raise ValueError("W3 wrapper expects 3D input (B, L, C) or (B, C, L).")
    _, a1, a2 = x.shape
    if a1 >= a2:
        return 1, 2  # (B, L, C)
    return 2, 1  # (B, C, L)
```

---

### 문제 4: _after_eval_save에서 tod_vec 중복 가져오기

**위치**: `experiments/w3_experiment.py`, line 372-376 및 line 455-458

**현재 코드**:

```python
# evaluate_test 메서드 (line 372-376)
def evaluate_test(self) -> Dict[str, Any]:
    try:
        tod_vec = build_test_tod_vector(self.cfg)
    except Exception:
        tod_vec = None
    # ... 사용 ...

# _after_eval_save 메서드 (line 455-458)
def _after_eval_save(self, ...):
    # ...
    try:
        tod_vec = build_test_tod_vector(self.cfg)
    except Exception:
        tod_vec = None
    # ... 사용 ...
```

**문제점**:

- `build_test_tod_vector`를 두 번 호출
- 비효율적 (동일한 데이터를 두 번 로드)

**수정 방안**:

```python
# W3Experiment 클래스에 인스턴스 변수 추가
def __init__(self, cfg: Dict[str, Any]):
    # ... 기존 코드 ...
    self._last_tod_vec: Optional[np.ndarray] = None  # 추가

# evaluate_test에서 저장
def evaluate_test(self) -> Dict[str, Any]:
    try:
        tod_vec = build_test_tod_vector(self.cfg)
        self._last_tod_vec = tod_vec  # 저장
    except Exception:
        tod_vec = None
        self._last_tod_vec = None
    # ... 나머지 코드 ...

# _after_eval_save에서 재사용
def _after_eval_save(self, ...):
    # ...
    tod_vec = self._last_tod_vec  # 재사용
    if tod_vec is not None:
        compute_and_save_w3_gate_tod_heatmap(...)
    # ...
```

---

### 문제 5: _moving_avg_1d 미사용 함수

**위치**: `experiments/w3_experiment.py`, line 88-109

**현재 코드**:

```python
def _moving_avg_1d(x: torch.Tensor, k: int, t_axis: int) -> torch.Tensor:
    """시간축 기준 이동평균을 적용."""
    if k <= 1:
        return x
    # ... 구현 ...
```

**문제점**:

- 함수가 정의되어 있지만 w3_experiment.py 어디에서도 호출되지 않음
- 데드 코드 (dead code)

**수정 방안**:

- 함수 제거 (또는 주석 처리)
- 향후 사용 가능성이 있다면 주석으로 "# 향후 사용 예정" 표시

---

## 수정 우선순위

| 순위 | 문제 | 중요도 | 영향 | 수정 난이도 |

|------|------|--------|------|-------------|

| 1 | evaluate_test 예외 처리 | MEDIUM | 디버깅 어려움 | 쉬움 |

| 2 | _W3PerturbWrapper.**init** 비효율 | LOW | 성능 미미 | 쉬움 |

| 3 | tod_vec 중복 가져오기 | LOW | 성능 미미 | 중간 |

| 4 | _detect_layout 애매모호함 | LOW | 실제 문제 가능성 낮음 | 쉬움 (주석만 추가) |

| 5 | _moving_avg_1d 미사용 | LOW | 없음 | 쉬움 |

---

## 구현 단계

### Phase 1: 예외 처리 개선 (필수)

**1.1. evaluate_test 예외 처리에 로깅 추가**

**파일**: `experiments/w3_experiment.py`, line 393-405

**수정 전**:

```python
except Exception:
    pass
```

**수정 후**:

```python
except Exception as e:
    import warnings
    warnings.warn(f"W3 compute_all_experiment_metrics failed: {e}")
```

---

### Phase 2: 초기화 로직 최적화 (권장)

**2.1. _W3PerturbWrapper.init 최적화**

**파일**: `experiments/w3_experiment.py`, line 168-179

**수정 전**:

```python
self.cfg = perturb_cfg.copy() if isinstance(perturb_cfg, dict) else _default_perturb_cfg(dataset)

defaults = _default_perturb_cfg(dataset)
for key, value in defaults.items():
    self.cfg.setdefault(key, value)
```

**수정 후**:

```python
# 기본값 가져오기
defaults = _default_perturb_cfg(dataset)

# 사용자 제공 값이 있으면 복사 후 기본값으로 채우기, 없으면 기본값 사용
if isinstance(perturb_cfg, dict):
    self.cfg = perturb_cfg.copy()
    for key, value in defaults.items():
        self.cfg.setdefault(key, value)
else:
    self.cfg = defaults
```

---

### Phase 3: 성능 최적화 (권장)

**3.1. tod_vec 중복 로드 제거**

**파일**: `experiments/w3_experiment.py`

**Step 3.1.1**: `__init__`에 인스턴스 변수 추가 (line 352 부근)

```python
self._last_hooks_data: Dict[str, Any] = {}
self._last_direct: Dict[str, Any] = {}
self._last_tod_vec: Optional[np.ndarray] = None  # 추가
```

**Step 3.1.2**: `evaluate_test`에서 tod_vec 저장 (line 372-376)

```python
try:
    tod_vec = build_test_tod_vector(self.cfg)
    self._last_tod_vec = tod_vec  # 저장
except Exception:
    tod_vec = None
    self._last_tod_vec = None
```

**Step 3.1.3**: `_after_eval_save`에서 재사용 (line 455-458 제거 및 수정)

```python
# 기존 try-except 블록 제거
# try:
#     tod_vec = build_test_tod_vector(self.cfg)
# except Exception:
#     tod_vec = None

# 대신 저장된 값 사용
tod_vec = self._last_tod_vec
```

---

### Phase 4: 코드 정리 (선택)

**4.1. _detect_layout 주석 개선**

**파일**: `experiments/w3_experiment.py`, line 74-85

docstring에 다음 추가:

```python
"""
입력 텐서의 시간축/채널축을 추정.
허용 형태: (B, L, C) 혹은 (B, C, L)
반환: (time_axis, channel_axis)

일반적으로 시계열 길이(L)가 채널 수(C)보다 크다고 가정.
L == C인 경우 (B, L, C)로 해석합니다.
"""
```

**4.2. _moving_avg_1d 함수 제거 또는 주석 처리**

**파일**: `experiments/w3_experiment.py`, line 88-109

**옵션 A**: 완전 제거

**옵션 B**: 주석으로 남기기

```python
# def _moving_avg_1d(x: torch.Tensor, k: int, t_axis: int) -> torch.Tensor:
#     """시간축 기준 이동평균을 적용. (현재 미사용)"""
#     ...
```

---

## 검증 단계

### Phase 5: 수정 검증

**5.1. 구문 검사**

```bash
python -m py_compile experiments/w3_experiment.py
```

**5.2. Import 검사**

```bash
python -c "from experiments.w3_experiment import W3Experiment; print('OK')"
```

**5.3. 단위 테스트 (wrapper 초기화)**

```python
import torch
import torch.nn as nn
from experiments.w3_experiment import _W3PerturbWrapper, _default_perturb_cfg

class Dummy(nn.Module):
    def forward(self, x): return x

# perturb_cfg=None 테스트 (최적화 검증)
wrap1 = _W3PerturbWrapper(Dummy(), mode="none", dataset="ETTm2", perturb_cfg=None)
assert wrap1.cfg is not None
assert "tod_shift" in wrap1.cfg
assert "smooth" in wrap1.cfg

# perturb_cfg 제공 테스트
custom_cfg = {"tod_shift": {"max_shift": 999}}
wrap2 = _W3PerturbWrapper(Dummy(), mode="tod_shift", dataset="ETTm2", perturb_cfg=custom_cfg)
assert wrap2.cfg["tod_shift"]["max_shift"] == 999
assert "smooth" in wrap2.cfg  # 기본값으로 채워져야 함

print("✓ Wrapper initialization tests passed")
```

---

## 예상 결과

### 수정 전

- 치명적 에러: 없음 ✓
- 잠재적 문제: 5개
- 비효율적인 코드: 있음
- 디버깅 어려움: 예외 무시

### 수정 후

- 치명적 에러: 없음 ✓
- 잠재적 문제: 0개
- 비효율적인 코드: 최소화
- 디버깅 용이: 예외 로깅

---

## 예상 소요 시간

- Phase 1 (예외 처리): 5분
- Phase 2 (초기화 최적화): 10분
- Phase 3 (성능 최적화): 15분
- Phase 4 (코드 정리): 10분
- Phase 5 (검증): 10분
- **총: 50분**

---

## 주의사항

1. **Phase 1은 필수**입니다. 예외 처리 개선은 향후 디버깅을 위해 중요합니다.