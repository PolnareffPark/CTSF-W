<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 129e5efb-451e-4558-885b-c15a14545ce2 -->
# W3 실험 치명적 에러 수정 플랜

## 검토 결과 요약

### 발견된 치명적 결함

1. **save_w3_window_errors_detail 함수 시그니처 불일치** (CRITICAL)
2. **save_w3_forest_detail_row plot_type 불일치** (CRITICAL)
3. **_append_or_update_results 매개변수 이름 불일치** (CRITICAL)
4. **baseline cache 로직 불필요** (MEDIUM)

### save_w3_window_errors_detail 누적 확인

**함수 구현**: ✅ 올바름

- Line 549-571: 하나의 CSV 파일에 순차적으로 누적하는 로직이 올바르게 구현됨
- `subset_keys = ["mode", "window_index"]`로 중복 제거
- 각 mode(none, tod_shift, smooth)가 같은 파일에 누적됨

**호출 코드**: ❌ 잘못됨

- 현재 paired 로직 사용 (base_errors, pert_errors 전달)
- 조언대로 sequential runner에서 세 번 호출해야 함

---

## 치명적 결함 1: save_w3_window_errors_detail 함수 시그니처 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `utils/experiment_plotting_metrics/w3_plotting_metrics.py`, line 493-498
- **호출 위치 1**: `experiments/w3_experiment.py`, line 634-648
- **호출 위치 2**: `experiments/w3_experiment.py`, line 737-743

### 함수 시그니처 (정의)

```python
def save_w3_window_errors_detail(
    ctx: Dict[str, Any],
    errors: np.ndarray,      # 단일 errors 배열
    mode: str,               # "none", "tod_shift", "smooth"
    out_root: str = "results"
) -> None:
```

### 현재 호출 코드 (잘못됨)

**Line 634-648 (evaluate_test 내부)**:

```python
_w3pm.save_w3_window_errors_detail(
    ctx={...},
    base_errors=_np.asarray(base_win, dtype=_np.float32),  # ❌ 잘못된 인자
    pert_errors=_np.asarray(cur_win, dtype=_np.float32),  # ❌ 잘못된 인자
    perturbation=current_mode,                            # ❌ 잘못된 인자
    out_root=str(RESULTS_ROOT),
)
```

**Line 737-743 (_after_eval_save 내부)**:

```python
save_w3_window_errors_detail(
    ctx=self._ctx(...),
    base_errors=np.asarray(base_we, dtype=np.float32),    # ❌ 잘못된 인자
    pert_errors=np.asarray(current_we, dtype=np.float32), # ❌ 잘못된 인자
    perturbation=mode,                                    # ❌ 잘못된 인자
    out_root=str(RESULTS_ROOT),
)
```

### 에러 발생 양상

```python
TypeError: save_w3_window_errors_detail() got an unexpected keyword argument 'base_errors'
```

### 해결 방안

**조언에 따르면**: Sequential runner에서 각 mode마다 한 번씩 호출해야 함

**수정 전략**:

1. `evaluate_test`에서 baseline cache 로직 제거
2. `_after_eval_save`에서 baseline cache 로직 제거
3. 각 mode별로 `save_w3_window_errors_detail(ctx, errors, mode, out_root)` 호출

---

## 치명적 결함 2: save_w3_forest_detail_row plot_type 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `utils/experiment_plotting_metrics/w3_plotting_metrics.py`, line 338-345
- **호출 위치**: `experiments/w3_experiment.py`, line 690-695

### 함수 정의

```python
def save_w3_forest_detail_row(
    ctx: Dict[str,Any],                    # plot_type='forest_plot'
    rmse_real: float, mae_real: float,
    detail_csv: str | Path,
) -> None:
    assert ctx.get("plot_type") == "forest_plot"  # ← "forest_plot" 기대
```

### 현재 호출 코드

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest"),  # ❌ "forest"
    ...
)
```

### 에러 발생 양상

```python
AssertionError: plot_type must be 'forest_plot'
```

### 해결 방안

`plot_type="forest"` → `plot_type="forest_plot"`로 변경

---

## 치명적 결함 3: _append_or_update_results 매개변수 이름 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `experiments/w3_experiment.py`, line 501
- **호출 위치**: `experiments/w3_experiment.py`, line 765-769

### 함수 정의

```python
def _append_or_update_results(self, csv_path, row_or_dict, subset_keys):
    # subset_keys 사용
    mask = _build_mask(df, r, subset_keys)
```

### 현재 호출 코드

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],  # ❌ subset=
)
```

### 에러 발생 양상

```python
TypeError: _append_or_update_results() got an unexpected keyword argument 'subset'
```

### 해결 방안

`subset=` → `subset_keys=`로 변경

---

## 잠재적 문제: baseline cache 로직 불필요 (MEDIUM)

### 문제 위치

- `experiments/w3_experiment.py`, line 606-650 (evaluate_test)
- `experiments/w3_experiment.py`, line 720-745 (_after_eval_save)

### 문제점

- Sequential runner에서는 baseline cache가 필요 없음
- 각 mode별로 직접 호출하면 됨
- 코드 복잡도만 증가시킴

### 해결 방안

- baseline cache 관련 코드 제거
- 각 mode별로 직접 `save_w3_window_errors_detail` 호출

---

## 구현 단계

### Phase 1: save_w3_forest_detail_row plot_type 수정 (CRITICAL)

**파일**: `experiments/w3_experiment.py`, line 691

**수정 전**:

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest"),
    ...
)
```

**수정 후**:

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest_plot"),
    ...
)
```

---

### Phase 2: _append_or_update_results 매개변수 이름 수정 (CRITICAL)

**파일**: `experiments/w3_experiment.py`, line 768

**수정 전**:

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],
)
```

**수정 후**:

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset_keys=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],
)
```

---

### Phase 3: save_w3_window_errors_detail 호출 수정 (CRITICAL)

**Step 3.1**: evaluate_test에서 baseline cache 로직 제거 및 단순화

**파일**: `experiments/w3_experiment.py`, line 597-655

**수정 전**:

```python
# --- Window error (per-window MSE) sequential handling -------------
# Baseline run: cache baseline win_errors to disk.
# Perturbed run: read baseline cache, write paired detail via plotting util.
current_mode = str(self.cfg.get("mode", self.cfg.get("perturbation", "none")))
dataset = str(self.cfg.get("dataset") or getattr(self, "dataset_tag", ""))
horizon = int(self.cfg.get("horizon", self.cfg.get("pred_len", 96)))
seed = int(self.cfg.get("seed", 0))
model_tag = str(self.cfg.get("model_tag", getattr(self, "model_tag", "HyperConv")))

# Prepare window_errors cache dir
RESULTS_ROOT = _Path(self.cfg.get("out_root", "results"))
EXP_TAG = str(self.cfg.get("experiment_type", "W3"))
win_dir = RESULTS_ROOT / f"results_{EXP_TAG}" / dataset / "window_errors"
win_dir.mkdir(parents=True, exist_ok=True)
baseline_cache = win_dir / f"_baseline_cache_H{horizon}_S{seed}.npy"

# Current run's per-window MSE vector
cur_win = direct.get("win_errors", None)

# Save baseline cache or materialize paired detail (delegated to plotting util)
if isinstance(cur_win, (list, tuple, _np.ndarray)):
    if current_mode == "none":
        # Baseline: store cache only
        try:
            _np.save(baseline_cache, _np.asarray(cur_win, dtype=_np.float32))
        except Exception as _e:
            print(f"[W3] Baseline window_errors cache failed: {_e}")
    else:
        # Perturbed: try to load baseline cache and save paired detail
        try:
            if baseline_cache.exists():
                base_win = _np.load(baseline_cache)
                # defer writing detail to plotting module
                try:
                    from utils.experiment_plotting_metrics import w3_plotting_metrics as _w3pm
                except Exception:
                    import utils.experiment_plotting_metrics.w3_plotting_metrics as _w3pm  # local run
                _w3pm.save_w3_window_errors_detail(
                    ctx={
                        "experiment_type": EXP_TAG,
                        "dataset": dataset,
                        "horizon": horizon,
                        "seed": seed,
                        "model_tag": model_tag,
                        "mode": current_mode,
                        "run_tag": f"{EXP_TAG}_{dataset}_{horizon}_{seed}_{current_mode}",
                    },
                    base_errors=_np.asarray(base_win, dtype=_np.float32),
                    pert_errors=_np.asarray(cur_win, dtype=_np.float32),
                    perturbation=current_mode,
                    out_root=str(RESULTS_ROOT),
                )
        except Exception as _e:
            print(f"[W3] Window-errors detail skipped: {_e}")

# We do not keep the raw vector inside 'direct' to avoid bloating CSV rows
direct.pop("win_errors", None)
```

**수정 후**:

```python
# --- Window error (per-window MSE) sequential handling -------------
# Sequential runner: each mode (none, tod_shift, smooth) calls this function once.
# The function accumulates results in a single CSV file per (dataset, horizon, seed).
current_mode = str(self.cfg.get("mode", self.cfg.get("perturbation", "none")))
dataset = str(self.cfg.get("dataset") or getattr(self, "dataset_tag", ""))
horizon = int(self.cfg.get("horizon", self.cfg.get("pred_len", 96)))
seed = int(self.cfg.get("seed", 0))
model_tag = str(self.cfg.get("model_tag", getattr(self, "model_tag", "HyperConv")))
EXP_TAG = str(self.cfg.get("experiment_type", "W3"))
RESULTS_ROOT = _Path(self.cfg.get("out_root", "results"))

# Current run's per-window MSE vector
cur_win = direct.get("win_errors", None)

# Save window errors for current mode (sequential accumulation)
if isinstance(cur_win, (list, tuple, _np.ndarray)):
    try:
        from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail
    except Exception:
        from utils.experiment_plotting_metrics import w3_plotting_metrics as _w3pm
        save_w3_window_errors_detail = _w3pm.save_w3_window_errors_detail
        
    save_w3_window_errors_detail(
        ctx={
            "experiment_type": EXP_TAG,
            "dataset": dataset,
            "horizon": horizon,
            "seed": seed,
            "model_tag": model_tag,
            "mode": current_mode,
            "run_tag": f"{EXP_TAG}_{dataset}_{horizon}_{seed}_{current_mode}",
        },
        errors=_np.asarray(cur_win, dtype=_np.float32),
        mode=current_mode,
        out_root=str(RESULTS_ROOT),
    )
except Exception as _e:
    print(f"[W3] Window-errors save skipped: {_e}")

# We do not keep the raw vector inside 'direct' to avoid bloating CSV rows
direct.pop("win_errors", None)
```

**Step 3.2**: _after_eval_save에서 baseline cache 로직 제거 및 단순화

**파일**: `experiments/w3_experiment.py`, line 720-745

**수정 전**:

```python
# ---- 4) Window-errors: sequential handling with baseline cache ----
# direct may still include a large vector 'win_errors' (per-window MSE).
current_we = direct.pop("win_errors", None)
baseline_cache = win_dir / f"_baseline_cache_H{horizon}_S{seed}.npy"

if mode == "none":
    # Cache baseline only; perturbed runs will load it to write paired detail CSV.
    try:
        if isinstance(current_we, (list, tuple, np.ndarray)):
            np.save(baseline_cache, np.asarray(current_we, dtype=np.float32))
    except Exception as e:
        print(f"[W3] baseline window_errors cache failed: {e}")
else:
    # For perturbed runs, write per-(H,S) paired detail if baseline cache exists.
    try:
        if baseline_cache.exists() and isinstance(current_we, (list, tuple, np.ndarray)):
            base_we = np.load(baseline_cache)
            save_w3_window_errors_detail(
                ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="window_errors"),
                base_errors=np.asarray(base_we, dtype=np.float32),
                pert_errors=np.asarray(current_we, dtype=np.float32),
                perturbation=mode,
                out_root=str(RESULTS_ROOT),
            )
    except Exception as e:
        print(f"[W3] window_errors detail save skipped: {e}")
```

**수정 후**:

```python
# ---- 4) Window-errors: sequential handling (already saved in evaluate_test) ----
# Window errors are saved in evaluate_test() for each mode sequentially.
# No additional processing needed here.
# (The direct dict may still have win_errors, but we already saved it)
direct.pop("win_errors", None)
```

**또는 완전히 제거** (evaluate_test에서 이미 처리하므로)

---

### Phase 4: 검증 (REQUIRED)

**Step 4.1**: 구문 검사

```bash
python -m py_compile experiments/w3_experiment.py
python -m py_compile utils/experiment_plotting_metrics/w3_plotting_metrics.py
```

**Step 4.2**: Import 검사

```bash
python -c "from experiments.w3_experiment import W3Experiment; from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail; print('OK')"
```

**Step 4.3**: 함수 시그니처 검증

```python
import inspect
from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail

sig = inspect.signature(save_w3_window_errors_detail)
params = list(sig.parameters.keys())
print(f"Parameters: {params}")

# 예상: ['ctx', 'errors', 'mode', 'out_root']
expected = ['ctx', 'errors', 'mode', 'out_root']
assert params == expected, f"Mismatch: {params} != {expected}"
print("✓ Signature verification passed")
```

**Step 4.4**: save_w3_window_errors_detail 누적 동작 테스트

```python
#!/usr/bin/env python3
"""Test sequential accumulation of window errors"""
import tempfile
import numpy as np
import pandas as pd
from pathlib import Path
from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail

with tempfile.TemporaryDirectory() as tmpdir:
    tmpdir = Path(tmpdir)
    
    ctx_base = {
        "experiment_type": "W3",
        "dataset": "ETTm2",
        "horizon": 96,
        "seed": 42,
        "model_tag": "CTSF",
        "run_tag": "W3_ETTm2_96_42_none",
    }
    
    # 1. Save baseline (none)
    errors_none = np.array([0.1, 0.2, 0.15, 0.18], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "none"},
        errors=errors_none,
        mode="none",
        out_root=str(tmpdir),
    )
    
    # 2. Save tod_shift
    errors_tod = np.array([0.12, 0.22, 0.17, 0.20], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "tod_shift", "run_tag": "W3_ETTm2_96_42_tod_shift"},
        errors=errors_tod,
        mode="tod_shift",
        out_root=str(tmpdir),
    )
    
    # 3. Save smooth
    errors_smooth = np.array([0.11, 0.21, 0.16, 0.19], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "smooth", "run_tag": "W3_ETTm2_96_42_smooth"},
        errors=errors_smooth,
        mode="smooth",
        out_root=str(tmpdir),
    )
    
    # 4. Verify accumulation
    detail_csv = tmpdir / "results_W3" / "ETTm2" / "window_errors" / "window_errors_detail_H96_S42.csv"
    assert detail_csv.exists(), "Detail CSV should exist"
    
    df = pd.read_csv(detail_csv)
    assert len(df) == 12, f"Expected 12 rows (4 per mode), got {len(df)}"
    
    modes = df["mode"].unique()
    assert set(modes) == {"none", "tod_shift", "smooth"}, f"Expected all modes, got {modes}"
    
    for mode in ["none", "tod_shift", "smooth"]:
        mode_df = df[df["mode"] == mode]
        assert len(mode_df) == 4, f"Expected 4 rows for {mode}, got {len(mode_df)}"
    
    print("✓ Sequential accumulation test passed!")
```

**Step 4.5**: 실제 실험 스모크 테스트

```bash
# ETTm2, none 모드로 간단 실행
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode none
```

---

## 수정 위치 요약

| 순번 | Line | 함수/위치 | 수정 내용 |

|------|------|-----------|-----------|

| 1 | 691 | `_after_eval_save` | `plot_type="forest"` → `plot_type="forest_plot"` |

| 2 | 768 | `_after_eval_save` | `subset=` → `subset_keys=` |

| 3 | 597-655 | `evaluate_test` | baseline cache 로직 제거, 단순 호출로 변경 |

| 4 | 720-745 | `_after_eval_save` | baseline cache 로직 제거 (또는 완전 삭제) |

---

## 예상 결과

### 수정 전

- `save_w3_window_errors_detail` 호출 시: `TypeError: got an unexpected keyword argument 'base_errors'`
- `save_w3_forest_detail_row` 호출 시: `AssertionError: plot_type must be 'forest_plot'`
- `_append_or_update_results` 호출 시: `TypeError: got an unexpected keyword argument 'subset'`
- W3 실험 완전 실패

### 수정 후

- 모든 함수가 정상 실행
- Window errors가 하나의 CSV 파일에 순차적으로 누적 (baseline, tod_shift, smooth)
- W3 실험 전체 파이프라인 정상 작동

---

## 예상 소요 시간

- Phase 1 (plot_type 수정): 2분
- Phase 2 (subset_keys 수정): 2분
- Phase 3 (window errors 호출 수정): 20분
- Phase 4 (검증): 15분
- **총: 39분**

---

## 주의사항

1. **Phase 3은 필수**입니다. 이것이 없으면 window errors가 전혀 저장되지 않습니다.

2. **Sequential runner 가정**: 이 수정은 sequential runner (none → tod_shift → smooth 순서로 실행)를 가정합니다. Parallel runner를 사용한다면 추가 수정이 필요할 수 있습니다.

3. **baseline cache 완전 제거**: evaluate_test와 _after_eval_save 모두에서 제거해야 합니다.

4. **함수 호출 순서**: 

   - Sequential runner에서 각 mode마다 `evaluate_test()` 호출
   - 각 호출에서 `save_w3_window_errors_detail(ctx, errors, mode, out_root)` 호출
   - 결과: 하나의 CSV 파일에 세 mode가 모두 누적됨

5. **검증 단계는 필수**입니다. 특히 Step 4.4의 누적 동작 테스트는 중요합니다.