<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 550d00cd-a145-486d-96b7-ae68a038fe59 -->
# W3 Experiment 치명적/잠재적 오류 수정 플랜

## 발견된 문제들

### 치명적 문제 1: `_default_perturb_cfg`가 None 반환 ⚠️ CRITICAL

**에러:**

```
AttributeError: 'NoneType' object has no attribute 'items'
at line 170: for key, value in defaults.items()
```

**원인:**

```python
def _default_perturb_cfg(dataset: str) -> Dict[str, Any]:
    ds = (dataset or "").lower()
    if "ettm2" in ds:
        return {...}
    if "etth2" in ds:
        return {...}
    # ❌ 여기에 return 문이 없음! → None 반환
```

**영향:** "ettm2"나 "etth2"가 아닌 모든 데이터셋(ETTm1, ETTh1, weather 등)에서 실행 즉시 실패

**해결:**

```python
def _default_perturb_cfg(dataset: str) -> Dict[str, Any]:
    ds = (dataset or "").lower()
    if "ettm2" in ds:
        return {
            "tod_shift": {"max_shift": 16, "seg_perm_k": 4, "per_channel_jitter": 2, "sdiff_beta": 0.15},
            "smooth":    {"kernel": 7,  "alpha": 0.5},
        }
    if "etth2" in ds:
        return {
            "tod_shift": {"max_shift": 4, "seg_perm_k": 3, "per_channel_jitter": 1},
            "smooth":    {"kernel": 7,  "alpha": 0.6},
        }
    # ✅ 기타 데이터셋용 기본값 추가
    return {
        "tod_shift": {"max_shift": max(1, _infer_tod_bins(dataset) // 48)},
        "smooth":    {"kernel": 5, "alpha": 0.3},
    }
```

**위치:** line 53-65

---

### 치명적 문제 2: 세그먼트 퍼뮤테이션 로직 오류 ⚠️ CRITICAL

**문제점:**

```python
# 현재 코드 (line 238-242)
x = torch.cat([x.index_select(t_axis, torch.arange(s.start, s.stop, device=x.device))
                for s in perm_slices if s.start < s.stop], dim=t_axis)
```

**오류:**

1. `index_select`의 첫 번째 인자는 dim이지만, 두 번째 인자로 넘긴 인덱스가 잘못됨
2. `torch.arange(s.start, s.stop)`는 **CPU** 텐서를 생성하지만 `device=x.device`를 지정해도 `index_select`에서 device mismatch 발생 가능
3. 세그먼트가 정확히 `L`을 채우지 못할 수 있음 (마지막 세그먼트 처리)

**해결:**

```python
# 2) 구간 퍼뮤테이션(세그먼트 순열)
if seg_k > 1 and L >= seg_k:
    seg_len = L // seg_k
    remainder = L % seg_k
    
    # 세그먼트 인덱스 생성
    segments = []
    start = 0
    for i in range(seg_k):
        end = start + seg_len + (1 if i < remainder else 0)
        segments.append((start, end))
        start = end
    
    # 무작위 순열
    order = torch.randperm(seg_k, device=x.device).tolist()
    
    # 세그먼트 재배열
    if t_axis == 1:  # (B, L, C)
        chunks = [x[:, segments[i][0]:segments[i][1], :] for i in order]
        x = torch.cat(chunks, dim=1)
    else:  # (B, C, L)
        chunks = [x[:, :, segments[i][0]:segments[i][1]] for i in order]
        x = torch.cat(chunks, dim=2)
```

**위치:** line 233-242

---

### 치명적 문제 3: 삼각 커널 생성 오류 ⚠️ CRITICAL

**문제점:**

```python
# 현재 코드 (line 264-266)
half = k // 2
tri = torch.arange(1, half + 2, device=x.device, dtype=x.dtype)
weight = torch.cat([tri, tri[-2::-1]]).view(1, 1, -1)
```

**오류:**

1. `k=7`일 때 `half=3`, `tri=[1,2,3,4]` (길이 4), `tri[-2::-1]=[3,2,1]` → 총 길이 7 맞음 ✓
2. **하지만** `k=5`일 때 `half=2`, `tri=[1,2,3]` (길이 3), `tri[-2::-1]=[2,1]` → 총 길이 5 맞음 ✓
3. **문제:** `dtype=x.dtype`인데 `x`가 float16이면 `torch.arange`가 float16 생성 → 정밀도 손실
4. **문제:** 커널이 정규화되지 않을 수 있음

**해결:**

```python
# (A) 삼각 커널로 부드럽게
half = k // 2
# float32로 커널 생성 후 정규화
tri = torch.arange(1, half + 2, device=x.device, dtype=torch.float32)
weight = torch.cat([tri, tri.flip(0)[1:]]).view(1, 1, -1)  # [1,2,3,2,1]
weight = weight / weight.sum()  # 정규화
```

**위치:** line 264-267

---

### 잠재적 문제 4: 채널별 시프트 로직 비효율 및 오류 가능성

**문제점:**

```python
# 현재 코드 (line 244-254)
for c in range(C):
    s = int(j[c].item())
    if s != 0:
        x_nc_t[:, c, :] = torch.roll(x_nc_t[:, c, :], shifts=s, dims=-1)
```

**오류:**

1. 루프가 느림 (C가 크면 비효율)
2. in-place 연산이 grad 문제 유발 가능 (하지만 `@torch.no_grad()` 안에 있으므로 괜찮음)

**개선:**

```python
# 3) 채널별 미세 시프트(동조성 약화) - vectorized
if ch_jitter > 0 and C > 1:
    if t_axis == 1:   # (B,L,C) → (B,C,L)
        x_nc_t = x.permute(0, 2, 1)
    else:
        x_nc_t = x
    B, C, LL = x_nc_t.shape
    
    # 채널별 독립 시프트 벡터화
    j = torch.randint(-ch_jitter, ch_jitter + 1, (C,), device=x.device)
    # 각 채널에 서로 다른 roll 적용 (vectorized 불가능하므로 루프 유지하되 간소화)
    x_shifted = []
    for c in range(C):
        shift_val = int(j[c].item())
        if shift_val != 0:
            x_shifted.append(torch.roll(x_nc_t[:, c:c+1, :], shifts=shift_val, dims=-1))
        else:
            x_shifted.append(x_nc_t[:, c:c+1, :])
    x_nc_t = torch.cat(x_shifted, dim=1)
    
    x = x_nc_t.permute(0, 2, 1) if t_axis == 1 else x_nc_t
```

**위치:** line 244-254

---

### 잠재적 문제 5: `win_errors` 처리 시 CSV 덮어쓰기 문제

**문제점:**

```python
# 현재 코드 (line 415-421)
dfw = pd.DataFrame({"run_tag": [run_tag]*w.size, "idx": np.arange(w.size), "rmse": w})
dfw.to_csv(win_dir / f"window_errors_{run_tag}.csv", index=False)
```

**오류:**

1. 같은 `run_tag`로 여러 번 실행하면 이전 결과 덮어씀
2. `run_tag`가 파일명에 포함되므로 너무 많은 파일 생성

**개선:**

```python
# run 별 원본 분포 저장 (append 모드)
win_dir = RESULTS_ROOT / f"results_{EXP_TAG}" / dataset / "window_errors"
win_dir.mkdir(parents=True, exist_ok=True)
win_csv = win_dir / "window_errors_detail.csv"

dfw = pd.DataFrame({
    "dataset": [dataset]*w.size,
    "horizon": [horizon]*w.size,
    "seed": [seed]*w.size,
    "mode": [mode]*w.size,
    "model_tag": [model_tag]*w.size,
    "idx": np.arange(w.size),
    "rmse": w
})

# append 또는 create
if win_csv.exists():
    old = pd.read_csv(win_csv)
    merged = pd.concat([old, dfw], ignore_index=True)
    # 같은 설정의 이전 run 제거
    subset = ["dataset", "horizon", "seed", "mode", "model_tag", "idx"]
    merged.drop_duplicates(subset=subset, keep="last", inplace=True)
    merged.to_csv(win_csv, index=False)
else:
    dfw.to_csv(win_csv, index=False)
```

**위치:** line 415-421

---

### 잠재적 문제 6: seasonal differencing 범위 체크 누락

**문제점:**

```python
# 현재 코드 (line 256-258)
if mix_beta > 1e-8:
    P = self.tod_bins
    if L > P:
        x = (1.0 - mix_beta) * x + mix_beta * (x - torch.roll(x, shifts=P, dims=t_axis))
```

**오류:**

1. `L <= P`일 때는 아무것도 안 함 → 의도대로지만 명시적으로 처리하는 게 좋음
2. `mix_beta`가 1.0에 가까우면 신호가 약해짐 → 경고 또는 클램핑 필요

**개선:**

```python
# 4) 약한 seasonal differencing 혼합(선택)
if mix_beta > 1e-8 and L > self.tod_bins:
    # mix_beta 클램핑 (0.0 ~ 0.3 권장)
    mix_beta = min(mix_beta, 0.3)
    P = self.tod_bins
    x = (1.0 - mix_beta) * x + mix_beta * (x - torch.roll(x, shifts=P, dims=t_axis))
```

**위치:** line 256-258

---

## 수정 우선순위

| 순위 | 문제 | 중요도 | 영향 |

|------|------|--------|------|

| 1 | `_default_perturb_cfg` None 반환 | CRITICAL | 즉시 실패 |

| 2 | 세그먼트 퍼뮤테이션 로직 | CRITICAL | 런타임 오류 |

| 3 | 삼각 커널 생성 | CRITICAL | 잘못된 결과 |

| 4 | 채널별 시프트 로직 | MEDIUM | 성능/안정성 |

| 5 | win_errors CSV 처리 | MEDIUM | 데이터 관리 |

| 6 | seasonal diff 범위 체크 | LOW | 안정성 |

---

## 구현 단계

### Phase 1: 치명적 문제 수정 (필수)

**1.1. `_default_perturb_cfg` 수정 (line 53-65)**

```python
def _default_perturb_cfg(dataset: str) -> Dict[str, Any]:
    """데이터셋별 기본 교란 강도 설정."""
    ds = (dataset or "").lower()
    if "ettm2" in ds:
        return {
            "tod_shift": {"max_shift": 16, "seg_perm_k": 4, "per_channel_jitter": 2, "sdiff_beta": 0.15},
            "smooth":    {"kernel": 7,  "alpha": 0.5},
        }
    if "etth2" in ds:
        return {
            "tod_shift": {"max_shift": 4, "seg_perm_k": 3, "per_channel_jitter": 1},
            "smooth":    {"kernel": 7,  "alpha": 0.6},
        }
    # 기타 데이터셋 (ETTm1, ETTh1, weather 등)
    tod_bins = _infer_tod_bins(dataset)
    return {
        "tod_shift": {"max_shift": max(1, tod_bins // 48), "seg_perm_k": 0, "per_channel_jitter": 0, "sdiff_beta": 0.0},
        "smooth":    {"kernel": 5, "alpha": 0.3},
    }
```

**1.2. 세그먼트 퍼뮤테이션 로직 수정 (line 233-242)**

```python
# 2) 구간 퍼뮤테이션(세그먼트 순열)
if seg_k > 1 and L >= seg_k:
    seg_len = L // seg_k
    remainder = L % seg_k
    
    # 세그먼트 경계 계산
    segments = []
    start = 0
    for i in range(seg_k):
        end = start + seg_len + (1 if i < remainder else 0)
        segments.append((start, end))
        start = end
    
    # 무작위 순열
    order = torch.randperm(seg_k, device=x.device).tolist()
    
    # 세그먼트 재배열
    if t_axis == 1:  # (B, L, C)
        chunks = [x[:, segments[i][0]:segments[i][1], :] for i in order]
        x = torch.cat(chunks, dim=1)
    else:  # (B, C, L)
        chunks = [x[:, :, segments[i][0]:segments[i][1]] for i in order]
        x = torch.cat(chunks, dim=2)
```

**1.3. 삼각 커널 생성 수정 (line 264-267)**

```python
# (A) 삼각 커널로 부드럽게
half = k // 2
tri = torch.arange(1, half + 2, device=x.device, dtype=torch.float32)
weight = torch.cat([tri, tri.flip(0)[1:]]).view(1, 1, -1)
weight = weight / weight.sum()  # 정규화
```

### Phase 2: 잠재적 문제 수정 (권장)

**2.1. 채널별 시프트 로직 개선 (line 244-254)**

- 현재 로직을 유지하되, 주석 개선 및 예외 처리 추가

**2.2. win_errors CSV 처리 개선 (line 415-421)**

- append 모드로 변경하여 데이터 손실 방지

**2.3. seasonal differencing 안전장치 (line 256-258)**

- `mix_beta` 클램핑 추가

### Phase 3: 검증

**3.1. 구문 검사**

```bash
python -m py_compile experiments/w3_experiment.py
```

**3.2. Import 검사**

```bash
python -c "from experiments.w3_experiment import W3Experiment; print('OK')"
```

**3.3. 단위 테스트 (교란 로직)**

```python
import torch
from experiments.w3_experiment import _W3PerturbWrapper, _default_perturb_cfg

# 기본값 테스트
assert _default_perturb_cfg("ETTm2") is not None
assert _default_perturb_cfg("ETTh2") is not None
assert _default_perturb_cfg("ETTm1") is not None  # ✓ None이 아니어야 함
assert _default_perturb_cfg("weather") is not None

# 교란 테스트
class Dummy(torch.nn.Module):
    def forward(self, x): return x

wrap = _W3PerturbWrapper(Dummy(), mode="tod_shift", dataset="ETTm2", perturb_cfg=None)
wrap.train()
x = torch.randn(2, 96, 7)  # (B, L, C)
y = wrap(x)
assert y.shape == x.shape
print("✓ Unit tests passed")
```

---

## 예상 결과

### 수정 전

- ETTh2: `AttributeError: 'NoneType' object has no attribute 'items'` (즉시 실패)
- ETTm1: 동일한 오류 (즉시 실패)
- ETTm2 (tod_shift 모드): 세그먼트 퍼뮤테이션에서 런타임 오류

### 수정 후

- 모든 데이터셋에서 정상 실행
- 강화된 교란 로직이 안정적으로 작동
- 결과 CSV가 올바르게 저장됨

---

## 예상 소요 시간

- Phase 1 (치명적 문제 수정): 20분
- Phase 2 (잠재적 문제 수정): 15분
- Phase 3 (검증): 10분
- 실제 실험 (smoke test): 40분
- **총: 85분**