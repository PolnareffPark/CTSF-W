<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 5d766a91-8cf3-491f-9400-43275f0e8db9 -->
# W3 _W3PerturbWrapper 무한 재귀 오류 최종 해결

## 문제 분석

### 발생한 에러

```python
RecursionError: maximum recursion depth exceeded
File "/experiments/w3_experiment.py", line 213, in __getattr__
    return getattr(self.base, name)
           ^^^^^^^^^\
[Previous line repeated 993 more times]
```

### 근본 원인

#### nn.Module의 속성 저장 메커니즘

```python
class _W3PerturbWrapper(nn.Module):
    def __init__(self, base: nn.Module, cfg: Dict[str, Any]):
        super().__init__()
        self.base = base  # ← nn.Module이 _modules['base']에 저장
```

**PyTorch nn.Module의 특별한 동작**:

- `self.base = base` → 내부적으로 `_modules['base'] = base` 저장
- 일반 속성처럼 `self.base` 접근 시도
- `__getattr__`가 정의되어 있으면 복잡한 상호작용 발생

#### 무한 재귀 발생 과정

1. `getattr(self.model, "model_tag")` 호출
2. wrapper에 `model_tag` 없음 → `__getattr__('model_tag')` 호출
3. `__getattr__` 내부: `getattr(self.base, 'model_tag')` 실행
4. **여기서 문제**: `self.base` 접근 시도
5. Python이 `self.base`를 찾으려고 시도
6. 일반 속성 접근 실패 (왜? nn.Module의 복잡한 메커니즘)
7. `__getattr__('base')` 호출
8. 다시 3번으로 돌아가서 무한 재귀

#### W5와의 차이

**W5 GateFixedModel**:

- 일반 클래스 (nn.Module 상속 없음)
- `self.model`이 일반 객체 속성 (`__dict__`)
- `__getattr__`에서 `self.model` 접근 시 재귀 없음

**W3 _W3PerturbWrapper**:

- nn.Module 상속
- `self.base`가 `_modules['base']`에 저장
- `__getattr__`에서 `self.base` 접근 시 재귀 발생 가능

## 해결 방안

### 옵션 A: object.**getattribute** 사용 (✓ 추천)

**원리**:

- `object.__getattribute__`는 Python의 최상위 속성 접근 메서드
- `__getattr__` 우회하여 직접 속성 접근
- 무한 재귀 방지

**구현**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근 (무한 재귀 방지)"""
    # object.__getattribute__를 사용하여 _modules['base']에 직접 접근
    try:
        # nn.Module은 서브모듈을 _modules dict에 저장
        modules = object.__getattribute__(self, '_modules')
        base = modules['base']
    except (AttributeError, KeyError):
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
    
    # base 모델의 속성으로 위임
    try:
        return getattr(base, name)
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

**장점**:

- 무한 재귀 완전 방지
- PyTorch의 내부 메커니즘 정확히 활용
- 명확하고 안전

### 옵션 B: super().**getattribute** 사용

**구현**:

```python
def __getattr__(self, name):
    try:
        base = super().__getattribute__('_modules')['base']
    except (AttributeError, KeyError):
        raise AttributeError(...)
    return getattr(base, name)
```

**단점**:

- nn.Module의 `__getattribute__`가 다시 복잡한 로직 실행
- 여전히 재귀 위험 존재

### 결론: 옵션 A 채택

## 전체 수정 사항

### 1. _W3PerturbWrapper.**getattr** 수정

**위치**: experiments/w3_experiment.py line 206-215

**현재**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근"""
    # __getattr__는 일반 속성 접근이 실패했을 때만 호출됨
    # self.base, self.cfg 등은 이미 nn.Module의 _modules 또는 __dict__에 있어
    # 일반 접근으로 찾을 수 있으므로 __getattr__가 호출되지 않음
    # 여기 도달했다는 것은 wrapper 자체에 없는 속성이므로 base로 위임
    try:
        return getattr(self.base, name)  # ← 무한 재귀 발생!
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

**수정**:

```python
def __getattr__(self, name):
    """base 모델의 속성에 투명하게 접근 (무한 재귀 방지)"""
    # object.__getattribute__를 사용하여 _modules['base']에 직접 접근
    # 이는 __getattr__를 우회하므로 무한 재귀를 방지함
    try:
        # nn.Module은 서브모듈을 _modules dict에 저장
        modules = object.__getattribute__(self, '_modules')
        base = modules['base']
    except (AttributeError, KeyError):
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
    
    # base 모델의 속성으로 위임
    try:
        return getattr(base, name)
    except AttributeError:
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
```

## 추가 검증

### A. w3_metrics.py 재검토

**현재 상태**: 파일이 원본과 동일

- `compute_w3_metrics` 함수만 존재
- 외부 데이터(baseline_metrics, perturb_metrics) 처리
- 모델 접근 없음
- **결론**: 문제 없음 ✓

### B. w3_plotting_metrics.py 재검토

**현재 상태**: 파일이 원본과 동일

- `hooks_data`, `tod_vec` 등 외부 데이터 처리
- 모델 직접 접근 없음
- `_collect_gate_arrays_from_hooks`는 hooks_data에서 데이터 추출만
- **결론**: 문제 없음 ✓

### C. evaluate_with_direct_evidence 호환성

**코드 경로**:

```python
W3Experiment.evaluate_test()
  → evaluate_with_direct_evidence(self.model, ...)
    → model.xhconv_blks 접근
      → wrapper.__getattr__('xhconv_blks')
        → object.__getattribute__(self, '_modules')['base'].xhconv_blks
```

**검증**:

- `model.xhconv_blks` 접근 시 `__getattr__('xhconv_blks')` 호출
- `object.__getattribute__`로 `base` 가져옴
- `base.xhconv_blks` 반환
- **결론**: 정상 동작 ✓

### D. LastBlockHooks 호환성

**코드 경로**:

```python
LastBlockHooks(model)
  → self._get_last_module(model, ["conv_blks", ...])
    → getattr(model, "conv_blks", None)
      → wrapper.__getattr__('conv_blks')
```

**검증**:

- `getattr(model, "conv_blks", None)` 호출
- wrapper에 없으면 `__getattr__('conv_blks')` 호출
- base 모델의 conv_blks 반환
- **결론**: 정상 동작 ✓

### E. GateOutputHooks 호환성

**코드 경로**:

```python
GateOutputHooks(model)
  → model.xhconv_blks 접근
    → wrapper.__getattr__('xhconv_blks')
```

**검증**: D와 동일

- **결론**: 정상 동작 ✓

## 예상 동작

### 속성 접근 시나리오

1. **wrapper 자체 속성**:
```python
wrapper.base           # _modules['base'] → 정상 접근
wrapper.cfg            # __dict__['cfg'] → 정상 접근
wrapper.mode           # __dict__['mode'] → 정상 접근
```

2. **base 모델 속성**:
```python
wrapper.xhconv_blks    # __getattr__('xhconv_blks') 
                       # → object.__getattribute__ → base.xhconv_blks
wrapper.model_tag      # __getattr__('model_tag')
                       # → object.__getattribute__ → base.model_tag
```

3. **존재하지 않는 속성**:
```python
wrapper.nonexistent    # __getattr__('nonexistent')
                       # → base.nonexistent 없음
                       # → AttributeError 발생
```


## 테스트 계획

### 1. 단위 테스트

```bash
python -c "
from experiments.w3_experiment import _W3PerturbWrapper
from models.ctsf_model import HybridTS
import torch

cfg = {'d_embed': 64, 'dropout_rate': 0.1, 'lookback': 96, 'patch_len': 16, 
       'cnn_depth': 3, 'horizon': 96, 'n_heads': 4, 'perturbation': 'none'}
base = HybridTS(cfg, n_vars=7)
wrapper = _W3PerturbWrapper(base, cfg)

# 테스트 1: base 접근
assert wrapper.base is base
print('✓ base 접근 성공')

# 테스트 2: xhconv_blks 접근
assert hasattr(wrapper, 'xhconv_blks')
print('✓ xhconv_blks 접근 성공')

# 테스트 3: model_tag 접근 (없어도 에러 안 남)
getattr(wrapper, 'model_tag', 'HyperConv')
print('✓ model_tag 접근 성공')

print('모든 테스트 통과!')
"
```

### 2. 통합 테스트

```bash
# 단일 실험
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode none

# 전체 모드
python run_suite.py --experiment W3 --datasets ETTm2 ETTh2 --horizons 96 --seeds 42 --resume all
```

### 3. 예상 결과

- ✓ RecursionError 없음
- ✓ AttributeError 없음
- ✓ 학습 완료
- ✓ 평가 완료
- ✓ 모드별 차별화된 결과

## 이전 시도들의 문제점 요약

### 시도 1: 명시적 체크

```python
if name in ('base', 'cfg', ...):
    raise AttributeError(...)
```

**문제**: `self.model.base` 접근 시 AttributeError 발생

### 시도 2: 명시적 체크 제거

```python
return getattr(self.base, name)
```

**문제**: `self.base` 접근 시 무한 재귀

### 시도 3 (최종): object.**getattribute**

```python
modules = object.__getattribute__(self, '_modules')
base = modules['base']
return getattr(base, name)
```

**결과**: 무한 재귀 방지, 정상 동작 ✓

## 요약

| 항목 | 상태 |

|------|------|

| 에러 유형 | RecursionError (무한 재귀) |

| 근본 원인 | __getattr__에서 self.base 접근 시 재귀 |

| 해결 방법 | object.**getattribute** 사용 |

| w3_metrics.py | 문제 없음 ✓ |

| w3_plotting_metrics.py | 문제 없음 ✓ |

| 호환성 | evaluate_with_direct_evidence, hooks 모두 호환 ✓ |

**결론**: object.__getattribute__를 사용한 근본적 해결