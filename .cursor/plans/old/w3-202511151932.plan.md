<!-- 9a93c5ab-08ec-4754-a148-7a9d1165d777 1773c3cf-cf3e-4646-afcc-beb0f8db1f5f -->
# W3 실험 치명적 에러 수정 플랜 (수정본)

## 실행 방식 이해

### Sequential Runner 동작 방식

**run_suite.py**에서 확인한 실행 패턴:

- W3 실험은 `modes = ["none", "tod_shift", "smooth"]`로 설정됨
- 각 mode마다 **별도의 독립적인 실행**이 이루어짐:

  1. 첫 번째 실행: `mode="none"` → `W3Experiment(cfg).run()` → `evaluate_test()` 호출
  2. 두 번째 실행: `mode="tod_shift"` → `W3Experiment(cfg).run()` → `evaluate_test()` 호출
  3. 세 번째 실행: `mode="smooth"` → `W3Experiment(cfg).run()` → `evaluate_test()` 호출

**중요**: 각 실행은 **독립적**이며, 각 실행에서 `self.cfg.get("mode")`는 현재 실행 중인 mode만 반환합니다.

### save_w3_window_errors_detail 누적 메커니즘

**함수 구현** (w3_plotting_metrics.py, line 549-571):

- 같은 파일 경로 (`window_errors_detail_H{horizon}_S{seed}.csv`)에 **append/update** 방식으로 저장
- `subset_keys = ["mode", "window_index"]`로 중복 제거
- 결과: 세 번의 실행이 끝나면 **하나의 CSV 파일**에 세 mode가 모두 누적됨

**예시**:

```
실행 1 (mode="none"):     → CSV에 none 데이터 추가
실행 2 (mode="tod_shift"): → 같은 CSV에 tod_shift 데이터 추가 (누적)
실행 3 (mode="smooth"):    → 같은 CSV에 smooth 데이터 추가 (누적)
최종 결과: 하나의 CSV에 세 mode 모두 포함
```

---

## 검토 결과 요약

### 발견된 치명적 결함

1. **save_w3_window_errors_detail 함수 시그니처 불일치** (CRITICAL)
2. **save_w3_forest_detail_row plot_type 불일치** (CRITICAL)
3. **_append_or_update_results 매개변수 이름 불일치** (CRITICAL)
4. **baseline cache 로직 불필요** (MEDIUM)

### save_w3_window_errors_detail 누적 확인

**함수 구현**: ✅ 올바름

- Line 549-571: 하나의 CSV 파일에 순차적으로 누적하는 로직이 올바르게 구현됨
- `subset_keys = ["mode", "window_index"]`로 중복 제거
- 각 mode(none, tod_shift, smooth)가 같은 파일에 누적됨

**호출 코드**: ❌ 잘못됨

- 현재 함수 시그니처와 맞지 않는 인자 전달 (`base_errors`, `pert_errors`, `perturbation`)
- baseline cache 로직이 불필요하게 복잡함
- 각 실행에서 **현재 mode의 errors만** 저장하면 되는데, paired 로직 사용

---

## 치명적 결함 1: save_w3_window_errors_detail 함수 시그니처 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `utils/experiment_plotting_metrics/w3_plotting_metrics.py`, line 493-498
- **호출 위치 1**: `experiments/w3_experiment.py`, line 634-648
- **호출 위치 2**: `experiments/w3_experiment.py`, line 737-743

### 함수 시그니처 (정의)

```python
def save_w3_window_errors_detail(
    ctx: Dict[str, Any],
    errors: np.ndarray,      # 단일 errors 배열 (현재 mode의 errors만)
    mode: str,               # "none", "tod_shift", "smooth" (현재 실행 중인 mode)
    out_root: str = "results"
) -> None:
```

### 현재 호출 코드 (잘못됨)

**Line 634-648 (evaluate_test 내부, mode != "none"일 때)**:

```python
_w3pm.save_w3_window_errors_detail(
    ctx={...},
    base_errors=_np.asarray(base_win, dtype=_np.float32),  # ❌ 잘못된 인자
    pert_errors=_np.asarray(cur_win, dtype=_np.float32),  # ❌ 잘못된 인자
    perturbation=current_mode,                            # ❌ 잘못된 인자
    out_root=str(RESULTS_ROOT),
)
```

**문제점**:

1. 함수는 `errors` 하나만 받는데 `base_errors`, `pert_errors` 두 개를 전달
2. 함수는 `mode`를 받는데 `perturbation`을 전달
3. `mode == "none"`일 때는 이 코드가 실행되지 않아서 none의 errors가 저장되지 않음

**Line 737-743 (_after_eval_save 내부, mode != "none"일 때)**:

```python
save_w3_window_errors_detail(
    ctx=self._ctx(...),
    base_errors=np.asarray(base_we, dtype=np.float32),    # ❌ 잘못된 인자
    pert_errors=np.asarray(current_we, dtype=np.float32), # ❌ 잘못된 인자
    perturbation=mode,                                    # ❌ 잘못된 인자
    out_root=str(RESULTS_ROOT),
)
```

**동일한 문제**

### 에러 발생 양상

```python
TypeError: save_w3_window_errors_detail() got an unexpected keyword argument 'base_errors'
```

### 해결 방안

**각 실행에서 현재 mode의 errors만 저장**:

- `mode == "none"` 실행: `save_w3_window_errors_detail(ctx, errors_none, mode="none", ...)`
- `mode == "tod_shift"` 실행: `save_w3_window_errors_detail(ctx, errors_tod, mode="tod_shift", ...)`
- `mode == "smooth"` 실행: `save_w3_window_errors_detail(ctx, errors_smooth, mode="smooth", ...)`

**각 호출은 같은 파일에 누적되므로, 세 번의 실행이 끝나면 하나의 CSV에 세 mode가 모두 포함됨**

---

## 치명적 결함 2: save_w3_forest_detail_row plot_type 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `utils/experiment_plotting_metrics/w3_plotting_metrics.py`, line 338-345
- **호출 위치**: `experiments/w3_experiment.py`, line 691

### 함수 정의

```python
def save_w3_forest_detail_row(
    ctx: Dict[str,Any],                    # plot_type='forest_plot'
    rmse_real: float, mae_real: float,
    detail_csv: str | Path,
) -> None:
    assert ctx.get("plot_type") == "forest_plot"  # ← "forest_plot" 기대
```

### 현재 호출 코드

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest"),  # ❌ "forest"
    ...
)
```

### 에러 발생 양상

```python
AssertionError: plot_type must be 'forest_plot'
```

### 해결 방안

`plot_type="forest"` → `plot_type="forest_plot"`로 변경

---

## 치명적 결함 3: _append_or_update_results 매개변수 이름 불일치 (CRITICAL)

### 문제 위치

- **함수 정의**: `experiments/w3_experiment.py`, line 501
- **호출 위치**: `experiments/w3_experiment.py`, line 768

### 함수 정의

```python
def _append_or_update_results(self, csv_path, row_or_dict, subset_keys):
    # subset_keys 사용
    mask = _build_mask(df, r, subset_keys)
```

### 현재 호출 코드

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],  # ❌ subset=
)
```

### 에러 발생 양상

```python
TypeError: _append_or_update_results() got an unexpected keyword argument 'subset'
```

### 해결 방안

`subset=` → `subset_keys=`로 변경

---

## 잠재적 문제: baseline cache 로직 불필요 (MEDIUM)

### 문제 위치

- `experiments/w3_experiment.py`, line 606-650 (evaluate_test)
- `experiments/w3_experiment.py`, line 720-745 (_after_eval_save)

### 문제점

- Sequential runner에서는 각 실행이 독립적이므로 baseline cache가 필요 없음
- 각 실행에서 현재 mode의 errors만 저장하면 됨
- 코드 복잡도만 증가시킴

### 해결 방안

- baseline cache 관련 코드 완전 제거
- 각 실행에서 현재 mode의 errors만 직접 저장

---

## 구현 단계

### Phase 1: save_w3_forest_detail_row plot_type 수정 (CRITICAL)

**파일**: `experiments/w3_experiment.py`, line 691

**수정 전**:

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest"),
    ...
)
```

**수정 후**:

```python
save_w3_forest_detail_row(
    ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="forest_plot"),
    ...
)
```

---

### Phase 2: _append_or_update_results 매개변수 이름 수정 (CRITICAL)

**파일**: `experiments/w3_experiment.py`, line 768

**수정 전**:

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],
)
```

**수정 후**:

```python
self._append_or_update_results(
    RESULTS_ROOT / f"results_{EXP_TAG}.csv",
    results_row,
    subset_keys=["dataset", "horizon", "seed", "mode", "model_tag", "experiment_type"],
)
```

---

### Phase 3: save_w3_window_errors_detail 호출 수정 (CRITICAL)

**핵심 원칙**: 각 실행에서 **현재 mode의 errors만** 저장

**Step 3.1**: evaluate_test에서 baseline cache 로직 제거 및 단순화

**파일**: `experiments/w3_experiment.py`, line 597-655

**수정 전**:

```python
# --- Window error (per-window MSE) sequential handling -------------
# Baseline run: cache baseline win_errors to disk.
# Perturbed run: read baseline cache, write paired detail via plotting util.
current_mode = str(self.cfg.get("mode", self.cfg.get("perturbation", "none")))
dataset = str(self.cfg.get("dataset") or getattr(self, "dataset_tag", ""))
horizon = int(self.cfg.get("horizon", self.cfg.get("pred_len", 96)))
seed = int(self.cfg.get("seed", 0))
model_tag = str(self.cfg.get("model_tag", getattr(self, "model_tag", "HyperConv")))

# Prepare window_errors cache dir
RESULTS_ROOT = _Path(self.cfg.get("out_root", "results"))
EXP_TAG = str(self.cfg.get("experiment_type", "W3"))
win_dir = RESULTS_ROOT / f"results_{EXP_TAG}" / dataset / "window_errors"
win_dir.mkdir(parents=True, exist_ok=True)
baseline_cache = win_dir / f"_baseline_cache_H{horizon}_S{seed}.npy"

# Current run's per-window MSE vector
cur_win = direct.get("win_errors", None)

# Save baseline cache or materialize paired detail (delegated to plotting util)
if isinstance(cur_win, (list, tuple, _np.ndarray)):
    if current_mode == "none":
        # Baseline: store cache only
        try:
            _np.save(baseline_cache, _np.asarray(cur_win, dtype=_np.float32))
        except Exception as _e:
            print(f"[W3] Baseline window_errors cache failed: {_e}")
    else:
        # Perturbed: try to load baseline cache and save paired detail
        try:
            if baseline_cache.exists():
                base_win = _np.load(baseline_cache)
                # defer writing detail to plotting module
                try:
                    from utils.experiment_plotting_metrics import w3_plotting_metrics as _w3pm
                except Exception:
                    import utils.experiment_plotting_metrics.w3_plotting_metrics as _w3pm  # local run
                _w3pm.save_w3_window_errors_detail(
                    ctx={
                        "experiment_type": EXP_TAG,
                        "dataset": dataset,
                        "horizon": horizon,
                        "seed": seed,
                        "model_tag": model_tag,
                        "mode": current_mode,
                        "run_tag": f"{EXP_TAG}_{dataset}_{horizon}_{seed}_{current_mode}",
                    },
                    base_errors=_np.asarray(base_win, dtype=_np.float32),
                    pert_errors=_np.asarray(cur_win, dtype=_np.float32),
                    perturbation=current_mode,
                    out_root=str(RESULTS_ROOT),
                )
        except Exception as _e:
            print(f"[W3] Window-errors detail skipped: {_e}")

# We do not keep the raw vector inside 'direct' to avoid bloating CSV rows
direct.pop("win_errors", None)
```

**수정 후**:

```python
# --- Window error (per-window MSE) sequential handling -------------
# Sequential runner: each mode (none, tod_shift, smooth) runs independently.
# Each run saves its own window errors to the same CSV file (accumulation).
# The function save_w3_window_errors_detail handles accumulation automatically.
current_mode = str(self.cfg.get("mode", self.cfg.get("perturbation", "none")))
dataset = str(self.cfg.get("dataset") or getattr(self, "dataset_tag", ""))
horizon = int(self.cfg.get("horizon", self.cfg.get("pred_len", 96)))
seed = int(self.cfg.get("seed", 0))
model_tag = str(self.cfg.get("model_tag", getattr(self, "model_tag", "HyperConv")))
EXP_TAG = str(self.cfg.get("experiment_type", "W3"))
RESULTS_ROOT = _Path(self.cfg.get("out_root", "results"))

# Current run's per-window MSE vector
cur_win = direct.get("win_errors", None)

# Save window errors for current mode (will accumulate in the same CSV file)
if isinstance(cur_win, (list, tuple, _np.ndarray)):
    try:
        from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail
    except Exception:
        from utils.experiment_plotting_metrics import w3_plotting_metrics as _w3pm
        save_w3_window_errors_detail = _w3pm.save_w3_window_errors_detail
        
    save_w3_window_errors_detail(
        ctx={
            "experiment_type": EXP_TAG,
            "dataset": dataset,
            "horizon": horizon,
            "seed": seed,
            "model_tag": model_tag,
            "mode": current_mode,
            "run_tag": f"{EXP_TAG}_{dataset}_{horizon}_{seed}_{current_mode}",
        },
        errors=_np.asarray(cur_win, dtype=_np.float32),
        mode=current_mode,
        out_root=str(RESULTS_ROOT),
    )
    except Exception as _e:
        print(f"[W3] Window-errors save skipped: {_e}")

# We do not keep the raw vector inside 'direct' to avoid bloating CSV rows
direct.pop("win_errors", None)
```

**Step 3.2**: _after_eval_save에서 baseline cache 로직 완전 제거

**파일**: `experiments/w3_experiment.py`, line 720-745

**수정 전**:

```python
# ---- 4) Window-errors: sequential handling with baseline cache ----
# direct may still include a large vector 'win_errors' (per-window MSE).
current_we = direct.pop("win_errors", None)
baseline_cache = win_dir / f"_baseline_cache_H{horizon}_S{seed}.npy"

if mode == "none":
    # Cache baseline only; perturbed runs will load it to write paired detail CSV.
    try:
        if isinstance(current_we, (list, tuple, np.ndarray)):
            np.save(baseline_cache, np.asarray(current_we, dtype=np.float32))
    except Exception as e:
        print(f"[W3] baseline window_errors cache failed: {e}")
else:
    # For perturbed runs, write per-(H,S) paired detail if baseline cache exists.
    try:
        if baseline_cache.exists() and isinstance(current_we, (list, tuple, np.ndarray)):
            base_we = np.load(baseline_cache)
            save_w3_window_errors_detail(
                ctx=self._ctx(dataset, horizon, seed, mode, model_tag, run_tag, plot_type="window_errors"),
                base_errors=np.asarray(base_we, dtype=np.float32),
                pert_errors=np.asarray(current_we, dtype=np.float32),
                perturbation=mode,
                out_root=str(RESULTS_ROOT),
            )
    except Exception as e:
        print(f"[W3] window_errors detail save skipped: {e}")
```

**수정 후**:

```python
# ---- 4) Window-errors: sequential handling (already saved in evaluate_test) ----
# Window errors are saved in evaluate_test() for each mode sequentially.
# Each run saves its own errors, and the function accumulates them in the same CSV file.
# No additional processing needed here.
# (The direct dict may still have win_errors, but we already saved it)
direct.pop("win_errors", None)
```

---

### Phase 4: 검증 (REQUIRED)

**Step 4.1**: 구문 검사

```bash
python -m py_compile experiments/w3_experiment.py
python -m py_compile utils/experiment_plotting_metrics/w3_plotting_metrics.py
```

**Step 4.2**: Import 검사

```bash
python -c "from experiments.w3_experiment import W3Experiment; from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail; print('OK')"
```

**Step 4.3**: 함수 시그니처 검증

```python
import inspect
from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail

sig = inspect.signature(save_w3_window_errors_detail)
params = list(sig.parameters.keys())
print(f"Parameters: {params}")

# 예상: ['ctx', 'errors', 'mode', 'out_root']
expected = ['ctx', 'errors', 'mode', 'out_root']
assert params == expected, f"Mismatch: {params} != {expected}"
print("✓ Signature verification passed")
```

**Step 4.4**: save_w3_window_errors_detail 누적 동작 테스트

```python
#!/usr/bin/env python3
"""Test sequential accumulation of window errors (simulating 3 separate runs)"""
import tempfile
import numpy as np
import pandas as pd
from pathlib import Path
from utils.experiment_plotting_metrics.w3_plotting_metrics import save_w3_window_errors_detail

with tempfile.TemporaryDirectory() as tmpdir:
    tmpdir = Path(tmpdir)
    
    ctx_base = {
        "experiment_type": "W3",
        "dataset": "ETTm2",
        "horizon": 96,
        "seed": 42,
        "model_tag": "CTSF",
    }
    
    # 시뮬레이션: 첫 번째 실행 (mode="none")
    print("Run 1: mode='none'")
    errors_none = np.array([0.1, 0.2, 0.15, 0.18], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "none", "run_tag": "W3_ETTm2_96_42_none"},
        errors=errors_none,
        mode="none",
        out_root=str(tmpdir),
    )
    
    # 시뮬레이션: 두 번째 실행 (mode="tod_shift") - 별도의 실행
    print("Run 2: mode='tod_shift'")
    errors_tod = np.array([0.12, 0.22, 0.17, 0.20], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "tod_shift", "run_tag": "W3_ETTm2_96_42_tod_shift"},
        errors=errors_tod,
        mode="tod_shift",
        out_root=str(tmpdir),
    )
    
    # 시뮬레이션: 세 번째 실행 (mode="smooth") - 별도의 실행
    print("Run 3: mode='smooth'")
    errors_smooth = np.array([0.11, 0.21, 0.16, 0.19], dtype=np.float32)
    save_w3_window_errors_detail(
        ctx={**ctx_base, "mode": "smooth", "run_tag": "W3_ETTm2_96_42_smooth"},
        errors=errors_smooth,
        mode="smooth",
        out_root=str(tmpdir),
    )
    
    # 검증: 하나의 CSV 파일에 세 mode가 모두 누적되었는지 확인
    detail_csv = tmpdir / "results_W3" / "ETTm2" / "window_errors" / "window_errors_detail_H96_S42.csv"
    assert detail_csv.exists(), "Detail CSV should exist"
    
    df = pd.read_csv(detail_csv)
    print(f"Total rows: {len(df)}")
    print(f"Modes: {df['mode'].unique()}")
    
    assert len(df) == 12, f"Expected 12 rows (4 per mode × 3 modes), got {len(df)}"
    
    modes = df["mode"].unique()
    assert set(modes) == {"none", "tod_shift", "smooth"}, f"Expected all modes, got {modes}"
    
    for mode in ["none", "tod_shift", "smooth"]:
        mode_df = df[df["mode"] == mode]
        assert len(mode_df) == 4, f"Expected 4 rows for {mode}, got {len(mode_df)}"
        print(f"  {mode}: {len(mode_df)} rows")
    
    print("✓ Sequential accumulation test passed!")
```

**Step 4.5**: 실제 실험 스모크 테스트

```bash
# 각 mode별로 별도 실행 (sequential runner 시뮬레이션)
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode none
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode tod_shift
python main.py --experiment W3 --dataset ETTm2 --horizon 96 --seed 42 --mode smooth

# 또는 run_suite.py 사용
python run_suite.py --experiment W3 --datasets ETTm2 --horizons 96 --seeds 42 --modes none tod_shift smooth
```

---

## 수정 위치 요약

| 순번 | Line | 함수/위치 | 수정 내용 |

|------|------|-----------|-----------|

| 1 | 691 | `_after_eval_save` | `plot_type="forest"` → `plot_type="forest_plot"` |

| 2 | 768 | `_after_eval_save` | `subset=` → `subset_keys=` |

| 3 | 597-655 | `evaluate_test` | baseline cache 로직 제거, 현재 mode의 errors만 저장 |

| 4 | 720-745 | `_after_eval_save` | baseline cache 로직 완전 제거 |

---

## 예상 결과

### 수정 전

- `save_w3_window_errors_detail` 호출 시: `TypeError: got an unexpected keyword argument 'base_errors'`
- `save_w3_forest_detail_row` 호출 시: `AssertionError: plot_type must be 'forest_plot'`
- `_append_or_update_results` 호출 시: `TypeError: got an unexpected keyword argument 'subset'`
- `mode == "none"` 실행 시 window errors가 저장되지 않음
- W3 실험 완전 실패

### 수정 후

- 모든 함수가 정상 실행
- 각 실행(mode=none/tod_shift/smooth)에서 해당 mode의 window errors가 저장됨
- 세 번의 실행이 끝나면 하나의 CSV 파일에 세 mode가 모두 누적됨
- W3 실험 전체 파이프라인 정상 작동

---

## 예상 소요 시간

- Phase 1 (plot_type 수정): 2분
- Phase 2 (subset_keys 수정): 2분
- Phase 3 (window errors 호출 수정): 20분
- Phase 4 (검증): 15분
- **총: 39분**

---

## 주의사항

1. **Phase 3은 필수**입니다. 이것이 없으면 window errors가 전혀 저장되지 않습니다.

2. **Sequential runner 이해**: 

   - 각 mode는 **별도의 독립적인 실행**입니다
   - 각 실행에서 `self.cfg.get("mode")`는 현재 실행 중인 mode만 반환합니다
   - 각 실행에서 현재 mode의 errors만 저장하면 됩니다
   - `save_w3_window_errors_detail` 함수가 같은 파일에 누적하므로, 세 번의 실행이 끝나면 하나의 CSV에 세 mode가 모두 포함됩니다

3. **baseline cache 완전 제거**: evaluate_test와 _after_eval_save 모두에서 제거해야 합니다.

4. **함수 호출 방식**:

   - 각 실행에서: `save_w3_window_errors_detail(ctx, errors, mode, out_root)`
   - `errors`: 현재 실행의 window errors (단일 배열)
   - `mode`: 현재 실행 중인 mode ("none", "tod_shift", 또는 "smooth")
   - 결과: 같은 파일에 누적됨

5. **검증 단계는 필수**입니다. 특히 Step 4.4의 누적 동작 테스트는 중요합니다.